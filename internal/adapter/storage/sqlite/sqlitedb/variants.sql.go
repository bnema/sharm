// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: variants.sql

package sqlitedb

import (
	"context"
)

const deleteVariantsByMedia = `-- name: DeleteVariantsByMedia :exec
DELETE FROM media_variants WHERE media_id = ?
`

func (q *Queries) DeleteVariantsByMedia(ctx context.Context, mediaID string) error {
	_, err := q.db.ExecContext(ctx, deleteVariantsByMedia, mediaID)
	return err
}

const getVariant = `-- name: GetVariant :one
SELECT id, media_id, codec, path, file_size, width, height, status, error_message, created_at FROM media_variants WHERE id = ? LIMIT 1
`

func (q *Queries) GetVariant(ctx context.Context, id int64) (MediaVariant, error) {
	row := q.db.QueryRowContext(ctx, getVariant, id)
	var i MediaVariant
	err := row.Scan(
		&i.ID,
		&i.MediaID,
		&i.Codec,
		&i.Path,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const getVariantByMediaAndCodec = `-- name: GetVariantByMediaAndCodec :one
SELECT id, media_id, codec, path, file_size, width, height, status, error_message, created_at FROM media_variants WHERE media_id = ? AND codec = ? LIMIT 1
`

type GetVariantByMediaAndCodecParams struct {
	MediaID string
	Codec   string
}

func (q *Queries) GetVariantByMediaAndCodec(ctx context.Context, arg GetVariantByMediaAndCodecParams) (MediaVariant, error) {
	row := q.db.QueryRowContext(ctx, getVariantByMediaAndCodec, arg.MediaID, arg.Codec)
	var i MediaVariant
	err := row.Scan(
		&i.ID,
		&i.MediaID,
		&i.Codec,
		&i.Path,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const insertVariant = `-- name: InsertVariant :one
INSERT INTO media_variants (media_id, codec, status, created_at)
VALUES (?, ?, 'pending', datetime('now'))
RETURNING id, media_id, codec, path, file_size, width, height, status, error_message, created_at
`

type InsertVariantParams struct {
	MediaID string
	Codec   string
}

func (q *Queries) InsertVariant(ctx context.Context, arg InsertVariantParams) (MediaVariant, error) {
	row := q.db.QueryRowContext(ctx, insertVariant, arg.MediaID, arg.Codec)
	var i MediaVariant
	err := row.Scan(
		&i.ID,
		&i.MediaID,
		&i.Codec,
		&i.Path,
		&i.FileSize,
		&i.Width,
		&i.Height,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const listVariantsByMedia = `-- name: ListVariantsByMedia :many
SELECT id, media_id, codec, path, file_size, width, height, status, error_message, created_at FROM media_variants WHERE media_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListVariantsByMedia(ctx context.Context, mediaID string) ([]MediaVariant, error) {
	rows, err := q.db.QueryContext(ctx, listVariantsByMedia, mediaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaVariant
	for rows.Next() {
		var i MediaVariant
		if err := rows.Scan(
			&i.ID,
			&i.MediaID,
			&i.Codec,
			&i.Path,
			&i.FileSize,
			&i.Width,
			&i.Height,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVariantDone = `-- name: UpdateVariantDone :exec
UPDATE media_variants SET
    status = 'done',
    path = ?,
    file_size = ?,
    width = ?,
    height = ?
WHERE id = ?
`

type UpdateVariantDoneParams struct {
	Path     string
	FileSize int64
	Width    int64
	Height   int64
	ID       int64
}

func (q *Queries) UpdateVariantDone(ctx context.Context, arg UpdateVariantDoneParams) error {
	_, err := q.db.ExecContext(ctx, updateVariantDone,
		arg.Path,
		arg.FileSize,
		arg.Width,
		arg.Height,
		arg.ID,
	)
	return err
}

const updateVariantStatus = `-- name: UpdateVariantStatus :exec
UPDATE media_variants SET status = ?, error_message = ? WHERE id = ?
`

type UpdateVariantStatusParams struct {
	Status       string
	ErrorMessage string
	ID           int64
}

func (q *Queries) UpdateVariantStatus(ctx context.Context, arg UpdateVariantStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateVariantStatus, arg.Status, arg.ErrorMessage, arg.ID)
	return err
}
