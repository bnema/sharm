package templates

templ Upload(version string) {
	@Layout(LayoutProps{Title: "Upload — Sharm", ShowNav: true, ActiveRoute: "upload", Version: version}) {
		@Card() {
			@CardHeader("Upload") {
				<span class="text-muted" style="font-size:var(--text-xs);">Images, videos, audio</span>
			}
			<form id="upload-form">
				@Dropzone("file", "video/*,image/*,audio/*")
				<!-- Codec selection (shown dynamically based on file type) -->
				<div id="codec-options" style="display:none;margin-top:var(--s-md);">
					<label class="text-muted" style="display:block;font-size:var(--text-xs);margin-bottom:var(--s-xs);">Conversion formats</label>
					<div style="display:flex;flex-direction:column;gap:var(--s-xs);">
						<label style="display:flex;align-items:center;gap:var(--s-sm);font-size:var(--text-sm);color:var(--text-muted);cursor:default;">
							<input type="checkbox" checked disabled/>
							<span>Original (always kept)</span>
						</label>
						<label id="codec-av1" style="display:none;align-items:center;gap:var(--s-sm);font-size:var(--text-sm);color:var(--text-primary);cursor:pointer;">
							<input type="checkbox" name="codecs" value="av1"/>
							<span>WebM (AV1)</span>
						</label>
						<label id="codec-h264" style="display:none;align-items:center;gap:var(--s-sm);font-size:var(--text-sm);color:var(--text-primary);cursor:pointer;">
							<input type="checkbox" name="codecs" value="h264"/>
							<span>MP4 (H264)</span>
						</label>
						<label id="codec-opus" style="display:none;align-items:center;gap:var(--s-sm);font-size:var(--text-sm);color:var(--text-primary);cursor:pointer;">
							<input type="checkbox" name="codecs" value="opus"/>
							<span>OGG (Opus)</span>
						</label>
					</div>
					<div id="fps-options" style="display:none;margin-top:var(--s-sm);">
						<label class="text-muted" style="display:block;font-size:var(--text-xs);margin-bottom:var(--s-xs);">Frame rate</label>
						<div style="display:flex;gap:var(--s-md);">
							<label style="display:flex;align-items:center;gap:var(--s-xs);font-size:var(--text-sm);color:var(--text-primary);cursor:pointer;">
								<input type="radio" name="fps" value="30" checked/>
								<span>30 FPS</span>
							</label>
							<label style="display:flex;align-items:center;gap:var(--s-xs);font-size:var(--text-sm);color:var(--text-primary);cursor:pointer;">
								<input type="radio" name="fps" value="60"/>
								<span>60 FPS</span>
							</label>
						</div>
					</div>
				</div>
				<div class="mt-md" style="display:flex;align-items:flex-end;gap:var(--s-sm);">
					<div style="flex:1;">
						<label class="text-muted" style="display:block;font-size:var(--text-xs);margin-bottom:var(--s-xs);">Retention</label>
						<select name="retention" class="input">
							<option value="1">1 day</option>
							<option value="3">3 days</option>
							<option value="7" selected>7 days</option>
							<option value="14">14 days</option>
							<option value="30">30 days</option>
						</select>
					</div>
					<button type="submit" class="button">Upload</button>
				</div>
			</form>
			@ProgressBar("upload-progress")
			<div id="probe-result" class="mt-md"></div>
			<div id="result" class="mt-md"></div>
		}
		<script>
			const CHUNK_SIZE = 5 * 1024 * 1024; // 5MB
			const MAX_RETRIES = 3;

			function generateUUID() {
				return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
					const r = Math.random() * 16 | 0;
					const v = c === 'x' ? r : (r & 0x3 | 0x8);
					return v.toString(16);
				});
			}

			function updateProgress(percent, text) {
				const bar = document.getElementById('upload-progress');
				const fill = document.getElementById('upload-progress-fill');
				const pct = document.getElementById('upload-progress-pct');
				if (!bar) return;
				bar.style.display = 'block';
				fill.style.width = percent + '%';
				pct.textContent = text || Math.round(percent) + '%';
			}

			async function uploadChunk(uploadId, chunkIndex, chunk, retries) {
				const fd = new FormData();
				fd.append('uploadId', uploadId);
				fd.append('chunkIndex', String(chunkIndex));
				fd.append('chunk', chunk);

				for (let attempt = 0; attempt <= retries; attempt++) {
					try {
						const resp = await fetch('/upload/chunk', {method: 'POST', body: fd});
						if (resp.ok) return true;
						if (attempt < retries) {
							await new Promise(r => setTimeout(r, Math.pow(2, attempt) * 1000));
						}
					} catch (e) {
						if (attempt < retries) {
							await new Promise(r => setTimeout(r, Math.pow(2, attempt) * 1000));
						}
					}
				}
				return false;
			}

			async function chunkedUpload(file, form) {
				const uploadId = generateUUID();
				const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
				const result = document.getElementById('result');

				for (let i = 0; i < totalChunks; i++) {
					const start = i * CHUNK_SIZE;
					const end = Math.min(start + CHUNK_SIZE, file.size);
					const chunk = file.slice(start, end);

					updateProgress((i / totalChunks) * 90, 'Uploading chunk ' + (i + 1) + '/' + totalChunks);

					const ok = await uploadChunk(uploadId, i, chunk, MAX_RETRIES);
					if (!ok) {
						result.innerHTML = '<div class="text-error" style="font-size:var(--text-sm);">Upload failed at chunk ' + (i + 1) + '. Please try again.</div>';
						updateProgress(0, '');
						document.getElementById('upload-progress').style.display = 'none';
						return false;
					}
				}

				updateProgress(95, 'Finalizing...');

				const fd = new FormData();
				fd.append('uploadId', uploadId);
				fd.append('filename', file.name);
				fd.append('totalChunks', String(totalChunks));
				fd.append('retention', form.querySelector('[name="retention"]').value);
				form.querySelectorAll('[name="codecs"]:checked').forEach(cb => fd.append('codecs', cb.value));
				const fpsInput = form.querySelector('[name="fps"]:checked');
				if (fpsInput) fd.append('fps', fpsInput.value);

				try {
					const resp = await fetch('/upload/complete', {method: 'POST', body: fd});
					if (resp.ok) {
						const redirect = resp.headers.get('HX-Redirect');
						if (redirect) {
							window.location.href = redirect;
						} else {
							updateProgress(100, 'Done!');
							window.location.href = '/';
						}
						return true;
					} else {
						const text = await resp.text();
						result.innerHTML = text || '<div class="text-error" style="font-size:var(--text-sm);">Upload failed</div>';
						updateProgress(0, '');
						document.getElementById('upload-progress').style.display = 'none';
						return false;
					}
				} catch (e) {
					result.innerHTML = '<div class="text-error" style="font-size:var(--text-sm);">Upload failed. Please try again.</div>';
					updateProgress(0, '');
					document.getElementById('upload-progress').style.display = 'none';
					return false;
				}
			}

			document.getElementById('upload-form').addEventListener('submit', async function(e) {
				e.preventDefault();
				const fileInput = this.querySelector('input[name="file"]');
				const file = fileInput?.files[0];
				if (!file) {
					document.getElementById('result').innerHTML = '<div class="text-error" style="font-size:var(--text-sm);">Please select a file</div>';
					return;
				}
				const submitBtn = this.querySelector('button[type="submit"]');
				submitBtn.disabled = true;
				document.getElementById('result').innerHTML = '';
				await chunkedUpload(file, this);
				submitBtn.disabled = false;
			});

			const fileInput = document.querySelector('input[name="file"]');
			if (fileInput) {
				const origOnchange = fileInput.getAttribute('onchange');
				fileInput.setAttribute('onchange', origOnchange + ';window._updateCodecOptions(this)');
			}

			window._updateCodecOptions = function(input) {
				const opts = document.getElementById('codec-options');
				const av1 = document.getElementById('codec-av1');
				const h264 = document.getElementById('codec-h264');
				const opus = document.getElementById('codec-opus');
				const fpsOpts = document.getElementById('fps-options');
				const probeResult = document.getElementById('probe-result');
				if (!input.files[0]) {
					opts.style.display = 'none';
					fpsOpts.style.display = 'none';
					return;
				}
				const name = input.files[0].name.toLowerCase();
				const videoExts = ['.mp4','.webm','.mov','.avi','.mkv','.flv','.wmv','.m4v'];
				const audioExts = ['.mp3','.wav','.ogg','.flac','.aac','.m4a','.wma','.opus'];
				const isVideo = videoExts.some(e => name.endsWith(e));
				const isAudio = audioExts.some(e => name.endsWith(e));

				if (isVideo) {
					opts.style.display = 'block';
					av1.style.display = 'flex';
					h264.style.display = 'flex';
					opus.style.display = 'none';
					window._updateFpsVisibility();
				} else if (isAudio) {
					opts.style.display = 'block';
					av1.style.display = 'none';
					h264.style.display = 'none';
					opus.style.display = 'flex';
					fpsOpts.style.display = 'none';
				} else {
					opts.style.display = 'none';
					fpsOpts.style.display = 'none';
				}

				if (probeResult && (isVideo || isAudio)) {
					window._probeClientSide(input.files[0], probeResult);
				} else if (probeResult) {
					probeResult.innerHTML = '';
				}
			};

			window._updateFpsVisibility = function() {
				const fpsOpts = document.getElementById('fps-options');
				const av1Checked = document.querySelector('#codec-av1 input')?.checked;
				const h264Checked = document.querySelector('#codec-h264 input')?.checked;
				fpsOpts.style.display = (av1Checked || h264Checked) ? 'block' : 'none';
			};

			document.querySelectorAll('#codec-av1 input, #codec-h264 input').forEach(function(cb) {
				cb.addEventListener('change', window._updateFpsVisibility);
			});

			window._probeClientSide = function(file, container) {
				const url = URL.createObjectURL(file);
				const isVideo = file.type.startsWith('video/') || /\.(mp4|webm|mov|avi|mkv|flv|wmv|m4v)$/i.test(file.name);

				if (isVideo) {
					const video = document.createElement('video');
					video.preload = 'metadata';
					video.onloadedmetadata = function() {
						const duration = video.duration;
						const width = video.videoWidth;
						const height = video.videoHeight;
						URL.revokeObjectURL(url);

						const formatDuration = function(sec) {
							if (!sec || !isFinite(sec)) return 'Unknown';
							const h = Math.floor(sec / 3600);
							const m = Math.floor((sec % 3600) / 60);
							const s = Math.floor(sec % 60);
							if (h > 0) return h + ':' + String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
							return m + ':' + String(s).padStart(2,'0');
						};
						const formatSize = function(bytes) {
							if (bytes >= 1073741824) return (bytes / 1073741824).toFixed(1) + ' GB';
							if (bytes >= 1048576) return (bytes / 1048576).toFixed(1) + ' MB';
							return (bytes / 1024).toFixed(1) + ' KB';
						};

						container.innerHTML = '<div style="background:var(--bg-elevated);border:1px solid var(--border);border-radius:var(--radius-md);padding:var(--s-sm) var(--s-md);font-size:var(--text-xs);">' +
							'<div style="display:flex;gap:var(--s-lg);flex-wrap:wrap;">' +
							'<div><span class="text-muted">Duration:</span> ' + formatDuration(duration) + '</div>' +
							'<div><span class="text-muted">Resolution:</span> ' + width + '×' + height + '</div>' +
							'<div><span class="text-muted">Size:</span> ' + formatSize(file.size) + '</div>' +
							'</div></div>';
					};
					video.onerror = function() {
						URL.revokeObjectURL(url);
						container.innerHTML = '<div class="text-muted" style="font-size:var(--text-xs);">Unable to read video metadata</div>';
					};
					video.src = url;
				} else {
					const audio = document.createElement('audio');
					audio.preload = 'metadata';
					audio.onloadedmetadata = function() {
						const duration = audio.duration;
						URL.revokeObjectURL(url);

						const formatDuration = function(sec) {
							if (!sec || !isFinite(sec)) return 'Unknown';
							const m = Math.floor(sec / 60);
							const s = Math.floor(sec % 60);
							return m + ':' + String(s).padStart(2,'0');
						};
						const formatSize = function(bytes) {
							if (bytes >= 1048576) return (bytes / 1048576).toFixed(1) + ' MB';
							return (bytes / 1024).toFixed(1) + ' KB';
						};

						container.innerHTML = '<div style="background:var(--bg-elevated);border:1px solid var(--border);border-radius:var(--radius-md);padding:var(--s-sm) var(--s-md);font-size:var(--text-xs);">' +
							'<div style="display:flex;gap:var(--s-lg);flex-wrap:wrap;">' +
							'<div><span class="text-muted">Duration:</span> ' + formatDuration(duration) + '</div>' +
							'<div><span class="text-muted">Size:</span> ' + formatSize(file.size) + '</div>' +
							'</div></div>';
					};
					audio.onerror = function() {
						URL.revokeObjectURL(url);
						container.innerHTML = '<div class="text-muted" style="font-size:var(--text-xs);">Unable to read audio metadata</div>';
					};
					audio.src = url;
				}
			};
		</script>
	}
}
